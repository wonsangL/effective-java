# Item 8. `finalizer`와 `cleaner` 사용을 피하라
`finalizer`는 실행 타이밍을 예상할 수 없고, 상황에 따라 성능 저하의 원인이 되기도 한다.

`cleaner`는 `finalizer`에 비해서는 덜 위험하지만 여전히 여러 단점을 가지고 있다.

## `finalizer`의 문제점
### 수행되는 타이밍을 알 수 없다.
객체가 접근할 수 없게된 이후 언제 `finalizer`를 수행하는 지 알수없다.

`finalizer`를 수행하는 시점은 garbage collector 알고리즘에 따라 다르다.

또한 수행 여부 또한 보장하지않기 때문에, 수행되지 않고 프로그램이 종료될 가능성도 있다.

만약 리소스를 반환하는 로직이 `finalizer`에 구현되어 있을 경우, 제때 리소스가 반환되지 않아, 
심각한 문제를 발생시킬 수 있다.

### `finalizer` 수행 중 발생한 예외는 무시된다.
`finalizer` 내부에서 예외가 발생할 경우, 이는 무시되고 호출 스택조차 출력되지 않는다.

또한 예외 처리 로직 안에 리소스를 반환하는 로직이 들어있을 경우, 위와 마찬가지로 심각한 문제가 발생할 수 있다.

### `finalizer`는 심각한 성능 문제를 동반한다.
`finalizer`는 garbage collector의 효율을 떨어뜨려 성능에 영향을 미친다.

### `finalizer` 공격에 취약하다.
> `finalizer` 공격이란, 생성자나 직렬화 과정에서 예외가 발생하면 
> 하위 클래스의 `finalizer` 를 수행시키는 공격을 의미한다.

해당 공격으로부터 방어하는 방법 중 하나는 아무것도 하지않는 `finalizer`를 선언하고
이를 `final`로 선언하는 것이다.

## `finalizer` 사용이 필요한 상황
### 리소스의 사용하고 `close` 메서드를 호출하지 않았을때, 안전장치 역할을 수행할 수 있다.
### native peer와 연결된 객체를 사용하는 경우
> native peer란 native 객체를 의미하고 해당 객체는 GC(Garbage Collection)의 대상이 되지 않는다.