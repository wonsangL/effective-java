# Item 7. 다 쓴 객체 참조를 해제하라
## 가비지 컬렉터를 갖춘 언어에서도 메모리 누수는 발생할 수 있다.
잘못된 객체 참조가 있을 경우, 해당 객체는 Garbage Collection(이하 GC)의 대상이 되지 않고,

해당 객체는 메모리 누수의 원인이 될 수 있다.

또한 해당 객체가 또 다른 객체를 참조하고 있을 경우, 영향은 더욱 커질 수 있다.

## 위 문제를 해결하는 방법
가장 단순한 방법은 `null`처리(참조 해제)를 하는 것

하지만 위 방법은 개발자가 신경써야하기 때문에 휴먼 에러를 발생시킬 가능성이 크다.

책에서는 위 방법외에 [Item 57. 지역 변수의 범위를 최소화하라](item_57.md)를 제시한다.

## `null` 처리가 필요한 경우
메모리 관리를 직접하는 경우는 위와 같이 `null`처리가 필요하다.

```
🤔 메모리 관리를 직접한다는 것은 어떤 의미인가? 
🤗 Garbage Collector가 객체 사용 여부를 파악할 수 없는 경우.
   즉, 사람이 객체의 사용 여부를 결정하는 경우를 의미하는 것으로 생각된다.
```

## 캐시 역시 메모리 누수를 일으키는 주범이다.
객체 참조를 캐시에 넣고 사용한 이후에 해제하지 않으면 역시나 메모리 누수의 원인이 될 수 있다.

key를 참조하는 동안만 엔트리가 살아있는 캐시가 필요할 경우, `WeakHaspMap`을 이용한 캐시 구현이 가능하다.

```
🤔 WeakHashMap는 결국 개발자가 null처리를 해줘야하는 구조가 아닌가?
   그렇다면 언제 null 처리해야하는지 명확하지 않은 경우도 존재하지 않을까?
🤗 위와 같은 상황을 해결하기 위해 다양한 eviction policy가 존재한다.
   주로 사용되는 eviction policy는 다음과 같다.
      - LRU(Least Recently Used): 비교적 가장 오래된 데이터부터 삭제하는 방법
      - LFU(Least Frequantly Used): 비교적 가장 적게 사용된 데이터부터 삭제하는 방법
      - TTL(Time To Live): 데이터가 저장될 수 있는 시간을 지정하는 방법
      - FIFO(Firth In First Out): 가장 먼저 저장된 데이터부터 삭제하는 방법
```

## 또 다른 메모리 누수의 주범은 리스너와 콜백이다.
콜백을 등록만하고 명확하게 해지하지 않으면 계속 해서 콜백이 쌓이게 될 수 있다.